<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function</title>
    <link rel="stylesheet" href="../CSS/function.css">
</head>

<body>
    <h1><b>JavaScript Function and Function Expressions</b></h1>
    <h2>JavaScript Function</h2>
    <p>A function is a block of code that performs a specific task.</p>
    <p>Suppose we need to create a program to create a circle and color it.
        we can create two functions to solve this problem:</p>
    <ul>
        <li>a function to draw the circle</li>
        <li>a function to color the circle</li>
    </ul>

    <p>Dividing a complex problem into smaller chunks makes our program easy to understand and reusable.</p>

    <p>JavaScript also has a huge number of inbuilt functions. <br>
        For example, Math.sqrt() is a function to calculate the square root of a number.</p>

    <h2>Declaring a Function</h2>
    <p>The syntax to declare a function is:</p>

    <div class="example">
        function nameOfFunction () { <br>
        // function body <br>
        } <br>
    </div>

    <ul>
        <li>A function is declared using the function keyword.</li>
        <li>The basic rules of naming a function are similar to naming a variable. <br>
            It is better to write a descriptive name for your function. <br>
            For example, if a function is used to add two numbers, you could name the function add or addNumbers.</li>
        <li>The body of function is written within {}</li>
    </ul>

    <p>For Example :</p>
    <div class="example"> <br>
        // declaring a function named greet() <br>
        function greet() { <br>
        console.log("Hello there"); <br>
        } <br>
    </div>

    <h2>Calling a Function</h2>
    <p>In the above program, we have declared a function named greet(). To use that function, we need to call it.</p>

    <div class="example">
        // function call <br>
        greet(); <br>

        Working of JavaScript function <br>
    </div>

    <img class="function-call" src="../IMAGES/javascript-function-example1.png" alt="">

    <h2><b>Example 1: Display a Text</b></h2>
    <div class="example">
        // program to print a text <br>
        // declaring a function <br>
        function greet() { <br>
        console.log("Hello there!"); <br>
        } <br>

        // calling the function <br>
        greet(); <br>
    </div>

    <h2>Function Parameters</h2>
    <p>A function can also be declared with parameters. A parameter is a value that is passed when declaring a function.
    </p>

    <img src="../IMAGES/javascript-function-with-parameter.png" alt="" class="function-parameter">

    <h2>Example 2: Function with Parameters</h2>
    <div class="example">
        // program to print the text <br>
        // declaring a function <br>
        function greet(name) { <br>
        console.log("Hello " + name + ":)"); <br>
        } <br>
        <br>
        // variable name can be different <br>
        let name = prompt("Enter a name: "); <br>
        <br>
        // calling function <br>
        greet(name);<br>

        <h3>Output</h3>

        Enter a name: Rohan <br>
        Hello Rohan :)
    </div>

    <h3>In the above program, the greet function is declared with a name parameter. <br>
        The user is prompted to enter a name. Then when the function is called, an argument is passed into the function.
    </h3>

    <div class="example">
        <b>Note</b>: When a value is passed when declaring a function, it is called <b>parameter</b>. <br>
        And when the function is called, the value passed is called <b>argument</b>.
    </div>

    <h2><b>Example 3: Add Two Numbers</b></h2>
    <div class="example">
        // program to add two numbers using a function <br>
        // declaring a function <br>
        function add(a, b) { <br>
        console.log(a + b); <br>
        } <br>

        // calling functions <br>
        add(9,4); <br>
        add(2,8); <br>

        <h3><b>Output</b></h3>
        13 <br>
        10
    </div>

    <h3>In the above program, the <b style="color: goldenrod;"> add </b>function is used to find the sum of two numbers.
    </h3>

    <ul>
        <li>The function is declared with two parameters a and b.</li>
        <li>The function is called using its name and passing two arguments 9 and 4 in one and 2 and 8 in another.</li>
    </ul>

    <div class="example">
        Notice that we can call a function as many times as we want. <br>
        we can write one function and then call it multiple times with different arguments.
    </div>

    <h2><b>Function Return</b></h2>
    <p>The return statement can be used to return the value to a function call.</p> <br>

    <p>The return statement denotes that the function has ended. Any code after return is not executed.</p> <br>

    <p>If nothing is returned, the function returns an undefined value.</p>

    <img src="../IMAGES/javascript-return-statement.png" alt="" class="function-return">

    <h2><b>Example 4: Sum of Two Numbers</b></h2>

    <div class="example">
        // program to add two numbers <br>
        // declaring a function <br>
        function add(a, b) { <br>
        return a + b; <br>
        } <br>

        // take input from the user <br>
        let number1 = parseFloat(prompt("Enter first number: ")); <br>
        let number2 = parseFloat(prompt("Enter second number: ")); <br>

        // calling function <br>
        let result = add(number1,number2); <br>

        // display the result <br>
        console.log("The sum is " + result); <br>


        <h3><b>Output</b></h3>
        Enter first number: 5.4 <br>
        Enter second number: 4 <br>
        The sum is 9.4 <br>
    </div>

    <p>In the above program, the sum of the numbers is returned by the function using the return statement. <br>
        And that value is stored in the result variable.</p> <br>

    <h3><b>Benefits of Using a Function</b></h3>
    <ul>
        <li>Function makes the code reusable. You can declare it once and use it multiple times.</li>
        <li>Function makes the program easier as each small task is divided into a function.</li>
        <li>Function increases readability.</li>
    </ul>

    <h2><b>Function Expressions</b></h2>
    <p>In Javascript, functions can also be defined as expressions. For example,</p>

    <div class="example">
        // program to find the square of a number <br>
        // function is declared inside the variable <br>
        let x = function (num) { return num * num }; <br>
        console.log(x(4)); <br>
        <br>
        // can be used as variable value for other variables <br>
        let y = x(3); <br>
        console.log(y); <br>

        <h3><b>OutPut :</b></h3>
        16 <br>
        9 <br>
    </div>

    In the above program, variable x is used to store the function. Here the function is treated as an expression. <br>
    And the function is called using the variable name. <br>

    The function above is called an <b>anonymous function</b>.

    <h2><b>JavaScript Nested functions</b></h2>
    <p>In JavaScript, Functions within another function are called “Nested function.” <br>
        These nested functions have access to the variables and parameters of the outer (enclosing) function, creating a
        scope hierarchy. <br>
        A function can have one or more inner functions. </p> <br>

    <p>Inner function can access variables and parameter of outer function. <br>
        However, outer finction cannot access variables defined inside inner functions.</p>

    <div class="example">
        // Outer function <br>
        function outerFunction() { <br>
        // Nested function <br>
        function nestedFunction() { <br>
        // Function logic here <br>
        } <br>
        // Call the nested function <br>
        nestedFunction(); <br>
        // Rest of the outer function logic <br>
        } <br>
        // Call the outer function <br>
        outerFunction(); <br>
    </div>
    <ul>
        <li>Write one function inside another function.</li>
        <li>Make a call to the inner function in the return statement of the outer function.</li>
        <li>Call it fun(a)(b) where a is a parameter to the outer and b is to the inner function.</li>
        <li>Finally, return the combined output from the nested function.</li>
    </ul>

    <h2><b>Example 1:</b></h2>
    <div class="example">
        function fun1(a) { <br>
        function fun2(b) { <br>
        return a + b; <br>
        } <br>
        return fun2; <br>
        } <br>
        function WEB_Fun() { <br>
        console.log(fun1("A Online Computer Science Portal") <br>
        (" WELCOME")); <br>
        } <br>
        WEB_Fun() <br>

        <H3><B>Output</B></H3>
        A Online Computer Science Portal WELCOME

    </div>

    <h2><b>Arrow Function</b></h2>
    <p>Arrow function {()=>} is concise way of writing JavaScript functions in shorter way. <br>
        Arrow functions were introduced in the ES6 version. <br>
        They make our code more structured and readable.</p> <br>

    <p>Arrow functions are anonymous functions i.e. functions without a name but they are often assigned to any
        variable. <br>
        They are also called Lambda Functions.</p>

    <div class="example">
        <h3><b>syntax</b></h3>
        const edureify = () => { <br>
        console.log( "Hi Namaste!" ); <br>
        } <br>
    </div>

    <h3><b>Arrow Function without Parameters</b></h3>

    <div class="example">

        const edureify = () => { <br>
        console.log( "Hi from Edureify!" ); <br>
        } <br>

        edureify();

    </div>

    <br>

    <h3><b>Arrow Function with Parameters</b></h3>

    <div class="example">
        const edureify = ( x, y, z ) => { <br>
        console.log( x + y + z ) <br>
        } <br>

        edureify( 10, 20, 30 ); <br>

    </div>

    <h3><b>Advantages of Arrow Functions :</b></h3>

    <ul>
        <li>Arrow functions reduce the size of the code.</li>
        <li>The return statement and function brackets are optional for single-line functions.</li>
        <li>It increases the readability of the code.</li>
    </ul>

    <h2>Callback Function</h2>
    <p>A callback function in javascript is a function that is passed as an argument in another function. <br>
        Which is then called inside the parent function to complete a routine or an action. <br>
        To put it more simply, it is a function that will be called(executed) later after its parent function(the
        function in which it is passed as an argument) is done executing.</p> <br>

    <h3>Example :</h3>
    <div class="example">
        function sum(a, b) { <br>
        console.log(a + b) <br>
        } <br>

        function operation(val1, val2, callback) { <br>
        callback(val1, val2) <br>
        } <br>

        operation(6, 5, sum) <br>

        <h3><b>output</b></h3>
        11


    </div>

    <p>In the above code, we can see in the function operation the third parameter is a callback function. <br>
        We are first passing the "callback" as an argument and then calling it inside the parent function i.e.,
        operation. <br>
        Here, we have taken the "sum" as the callback function, we can create any function and pass it as the callback
        in the operation function.</p>

    <h3><b>1. Synchronous Callback Function</b></h3>
    <p>The code executes sequentially - synchronous programming.</p>
    <div class="example">
        console.log('Start') <br>

        function divide(a, b) { <br>
        console.log(a / b) <br>
        } <br>
        <br>
        function operation(val1, val2, callback) { <br>
        callback(val1, val2) <br>
        } <br>
        <br>
        operation(16, 4, divide) <br>
        <br>
        console.log('End') <br>

        <h2><b>Output</b></h2>
        Start <br>
        4 <br>
        End <br>
    </div>

    <br>

    <h3><b>2. setTimeout() - Asynchronous Callback Function</b></h3>
    <div class="example">
        console.log('Start') <br>

        setTimeout(() => { <br>
        console.log('We are in the setTimeout()') <br>
        }, 4000) <br>

        console.log('End') <br>

        <h2><b>Output</b></h2>
        Start <br>
        End <br>
        We are in the setTimeout() <br>
    </div>

    <p>The console.log("End"); statement get executed before the setTimeout() function. <br>
        This is called asynchronous programming.</p>
    <br>

    <p>setTimeout() function takes two parameters the first one is a callback function and the second parameter is the
        time value in milliseconds. <br>
        The callback function will get executed after the amount of time specified in the second parameter.</p>

    <h3><b>3. Asynchronous Callback Function</b></h3>
    <p>When we fetch data from a server we get it after some delay. <br>
        The browser doesn't stay idle for that time and it moves to execute the next statement in the javascript
        program. To execute a block of code or provide the fetched data to the next function in the program we use the
        asynchronous callback function.</p>

    <div class="example">
        Note : <br>
        Here we are using the setTimeout() function to imitate the delay in sending the data by the server.
    </div>

    <br>

    <div class="example">
        console.log('Start') <br>

        function loginUserServer(email, callback) { <br>
        setTimeout(() => { <br>
        console.log('We have the data') <br>
        callback({ userEmail: email }) <br>
        }, 5000) <br>
        } <br>
        <br>
        const user = loginUserServer('xyz@gmail.com', (user) => { <br>
        console.log(user) <br>
        }) <br>
        <br>
        console.log('End')<br>

        <h2><b>output :</b></h2>

        Start <br>
        End <br>
        We have the data <br>
        { userEmail: 'xyz@gmail.com' } <br>


    </div>

    <h3><b>Higher Order Function</b></h3>
    <p>A higher order function is a function that takes one or more functions as arguments, or returns a function as its
        result.</p> <br>
    <br>
    <p>There are several different types of higher order functions like map and reduce.</p>

    <div class="example">
        function getNum(number) { <br>
        return number <br>
        } <br>

    </div>

    <p>In the above code block, We are using the getNum function to get the number. Here, getNum is a first-order
        function.</p>

    <div class="example">
        function twiceNum(number) { <br>
        return function () { <br>
        return number * 2 <br>
        } <br>
        } <br>
        let twiceTwo = twiceNum(2) <br>
        twiceTwo() <br>

    </div>

    <p>In the above code block, We wrote a function that returns a function. <br>
        Hence, the twiceNum is a Higher order function. Therefore, The function that returns a function, operates on
        another function, or takes another function as an argument is called a higher-order function in javascript.</p>

    <h2><b></b></h2>

    <div class="example">
        // add two numbers <br>
        function sum(a, b) { <br>
        } <br>

        // multiply two numbers <br>
        function mul(a, b) { <br>
        return a * b <br>
        } <br>

        //operate with a higher-order function <br>
        function calculate(operation, numsArray) { <br>
        if (numsArray.length <= 2) { <br>
            let a=numsArray[0] <br>
            let b=numsArray[1] <br>
            // return a function <br>
            return operation(a, b) <br>
            } <br>
            } <br>
            // calculate the sum of two numbers <br>
            console.log(calculate(sum, [5, 6])) // output: 11 // <br>
            calculate the multiplication of two numbers <br>
            console.log(calculate(mul, [10, 3])) // output: 30 <br>
    </div> <br>

    <ul>
        <li>In the above code block, we wrote two simple methods sum and mul that perform the addition and
            multiplication of two numbers respectively.</li>
        <li>Then, We wrote another function that can take two arguments : operation as a function and numsArray as an
            array. <br>
            Hence calculate function is a higher-order function.</li>
        <li>calculate(sum, [5, 6]) uses the sum() method and performs addition on the numbers in the array.</li>
        <li>calculate(mul, [10, 3]) uses the mul() method and performs addition on the numbers in the array.</li>
    </ul>

    <h3><b>First Class Function</b></h3>
    <p>In JavaScript, functions are first-class citizens, which means they can be treated like any other variable, <br>
        such as a number or a string. This allows you to use functions in a flexible and powerful way. <br>
        Here are some characteristics of first-class functions in JavaScript:</p>

    <ul>
        <li><b>
                <h3>Assigning to Variables:</h3>
            </b></li>
    </ul>
    <p>we can assign a function to a variable.</p>

    <div class="example">
        const sayHello = function() { <br>
        console.log('Hello, world!'); <br>
        }; <br>

    </div>

    <ul>
        <li><b>
                <h3>Passing as Arguments:</h3>
            </b></li>
    </ul>
    <p>Functions can be passed as arguments to other functions.</p>

    <div class="example">
        function greet(greetingFunction) { <br>
        greetingFunction(); <br>
        }; <br>
        greet(sayHello);

    </div>

    <ul>
        <li><b>
                <h3>Returning from Functions:</h3>
            </b></li>
    </ul>
    <p>Functions can be returned from other functions.</p>

    <div class="example">
        function getGreeter() { <br>
        return function() { <br>
        console.log('Greetings!'); <br>
        }; <br>
        } <br>

        const greeter = getGreeter(); <br>
        greeter(); <br>

        // Outputs: Greetings!

    </div>

    <ul>
        <li><b>
                <h3>Storing in Data Structures:</h3>
            </b></li>
    </ul>
    <p>Functions can be stored in data structures like arrays or objects.</p>

    <div class="example">
        const functionArray = [sayHello, function() { console.log('Hi there!'); }]; <br>
        <br>
        functionArray[0](); <br>
        // Outputs: Hello, world! <br>
        functionArray[1](); <br>
        // Outputs: Hi there! <br>


    </div>

    <ul>
        <li><b>
                <h3>Creating on the Fly:</h3>
            </b></li>
    </ul>
    <p>We can create functions on the fly (anonymous functions).</p>

    <div class="example">
        const add = function(a, b) { <br>
        return a + b; <br>
        }; <br>

        console.log(add(3, 4)); // Outputs: 7 <br>
    </div>


    <ul>
        <li><b>
                <h3>Closures:</h3>
            </b></li>
    </ul>
    <p>Functions in JavaScript form closures,
        allowing them to access variables from their containing scope even after the scope has finished executing.</p>

    <div class="example">
        function outerFunction(x) { <br>
        return function(y) { <br>
        console.log(x + y); <br>
        }; <br>
        } <br>
        <br>
        const innerFunction = outerFunction(5); <br>
        innerFunction(3); <br>
        // Outputs: 8

    </div>

    <h3><b>Pure Function</b></h3>
    <p>A pure function in JavaScript is a function that meets two main criteria:</p>
    <ul>
        <li><b>Deterministic: </b></li>
        <p>The function should produce the same output for the same input every time it is called. <br>
            There should be no reliance on external state that may change between calls.</p>
    </ul>

    <ul>
        <li><b>No Side Effects: </b></li>
        <p>The function should not modify any external state or have any observable side effects. <br>
            It should not mutate input parameters, modify global variables, perform I/O operations, <br>
            or anything else that could affect the program's state outside of the function.</p>
    </ul>

    <div class="example">
        // Pure function <br>
        function add(a, b) { <br>
        return a + b; <br>
        } <br>
        <br>
        const result = add(3, 4); // Result is always 7 <br>
        <br>
        // Another example <br>
        function multiplyByTwo(x) { <br>
        return x * 2; <br>
        } <br>
        <br>
        const doubledValue = multiplyByTwo(5); // Result is always 10 <br>
        <br>

        In these examples, the add and multiplyByTwo functions are pure. <br>
        They take inputs and return outputs without modifying any external state.
    </div>

    <h2><b> Impure function</b></h2>
    <div class="example">
        // Impure function <br>
        let total = 0; <br>

        function addToTotal(x) { <br>
        total += x; <br>
        return total; <br>
        } <br>
        <br>
        const currentTotal = addToTotal(5); <br>
        // Result depends on the current state of 'total' <br>
    </div>

    <!-- <script>
        const sayHello = function () {
            console.log('Hello, world!');
        };

        const functionArray = [sayHello, function () { console.log('Hi there!'); }];

        functionArray[0]();
        functionArray[1]();

    </script> -->

    <h3><b>IIFE Function</b></h3>
    <p>IIFE stands for "Immediately Invoked Function Expression." <br>
        It is a design pattern in JavaScript where a function is defined and executed immediately after its creation.
        <br>
        The primary purpose of using IIFE is to create a new scope for the variables within the function, preventing
        them from polluting the global scope.
    </p>

    <div class="example">
        <h3><b>Here's the basic syntax of an IIFE:</b></h3>
        (function() { <br>
        // code goes here <br>
        })(); <br>

    </div>
    <br>
    <div class="example">
        <h3><b>we can also pass parameter in IIFE</b></h3>
        (function(x, y) { <br>
        // code that uses x and y <br>
        })(10, 20); <br>
    </div>

    <br>

    <div class="example">
        (function() { <br>
        var message = "Hello, IIFE!"; <br>
        console.log(message); <br>
        })(); <br>
        // Output: Hello, IIFE! <br>
        <br>
        // The variable 'message' is not accessible outside the IIFE scope <br>
        // console.log(message); // This would result in an error <br>

    </div>

    <!-- <script>
        (function () {
            var message = "Hello, IIFE!";
            console.log(message);
        })();
        

    </script> -->

    <h3><b>Currying Function</b></h3>
    <p>Currying takes a function that receives more than one parameter and breaks it into a series of unray (one
        parameter) functions. <br>
        Hence, the currying function takes only one parameter at a time.</p>

    <ul>
        <b>Uses of Currying Function</b>
        <p>Currying in JavaScript can be for the following reasons:</p>

        <li>Currying is helpful in Event handling.</li>
        <li> By using the currying function, we can avoid passing the same variable many times.</li>
        <li>Currying in JavaScript can be used to make a higher-order function.
        </li>

    </ul>

    <h2><b>Currying in JavaScript can be used to make a higher-order function.</b></h2>

    <p>currying in JavaScript is a function that takes multiple arguments. <br>
        In it, the function is transformed into a number of functions, <br>
        and each of these series of functions will accept one argument.</p>

    <h3><b>Example One: A Simple, Three-Parameter Function</b></h3>
    <div class="example">
        <p>const addition =(x, y, z)=>{ <br>
            return x+y+z <br>
            } <br>
            console.log(addition(2, 3, 5)) // 10 <br>
        </p>
    </div>

    <h3><b>Example two: Converting an Existing Function into a Curried Function</b></h3>

    <div class="example">
        function sum(x) { // x is taken as argument here <br>
        return (y) => { <br>
        return (z) => { // this function will return the sum <br>
        return x + y + z <br>
        } <br>
        } <br>
        } <br>
        console.log(sum(1)(2)(3)) // 6 <br>
        <br>
        <h3><b>Explanation:</b> In the above example, we '1' is passed to the function "sum". It will return a function
            like:</h3>


        return (y) => { <br>
        return (z) => { <br>
        return x + y + z <br>
        } <br>
        } <br>

        <h3>Now, the above function definition will be treated as "sum1" and takes "b" as an argument. <br>
            Then we will call the function "sum1" and pass this in 2. Then the sum1 will return the third function as-
        </h3>

        return (z) => { <br>
        return x + y + z <br>
        } <br>


    </div>

    <h2><b>Example Three: Creating a Friend Request Curry Function</b></h2>
    <div class="example">
        function sendReq(greet){ //function is created that will take one argument, 'greet' here <br>
        return function(name){ <br>
        return function(message){ // name of person and the message is the return value here <br>
        return `${greet} ${name}, ${message}` <br>
        } <br>
        } <br>
        } <br>
        sendReq('Hello')('John')('Can you please add me as your connection on LinkedinIn ?') <br>

    </div>

    <div class="btn-last">
        <a class="next2" href="/JavaScript/Condtional in js/loops.html">Previous Page</a>
        <a class="next2" href="/JavaScript/String/string.html" target="_blank">Next Page</a> 
     </div>






</body>

</html>